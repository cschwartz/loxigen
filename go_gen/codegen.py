# Copyright 2013, Big Switch Networks, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

from collections import defaultdict
import os
import loxi_globals
import template_utils
import loxi_utils.loxi_utils as utils
import util
from loxi_ir import *

# Map from inheritance root to module name
roots = {
    'of_header': 'message',
    'of_action': 'action',
    'of_action_id': 'action_id',
    #'of_oxm': 'oxm',
    'of_instruction': 'instruction',
    'of_instruction_id': 'instruction_id',
    'of_meter_band': 'meter_band',
    #'of_bsn_tlv': 'bsn_tlv',
    'of_port_desc_prop': 'port_desc_prop',
    'of_port_stats_prop': 'port_stats_prop',
    'of_port_mod_prop': 'port_mod_prop',
    'of_table_mod_prop': 'table_mod_prop',
    'of_queue_desc_prop': 'queue_desc_prop',
    'of_queue_stats_prop': 'queue_stats_prop',
    'of_async_config_prop': 'async_config_prop',
    'of_bundle_prop': 'bundle_prop',
    #'of_queue_prop': 'queue_prop',
    'of_role_prop': 'role_prop',
    #'of_table_feature_prop': 'table_feature_prop',
    'of_table_mod_prop': 'table_mod_prop',
}

# Return the module and class names for the generated Python class
def generate_pyname(ofclass):
    for root, module_name in roots.items():
        if ofclass.name == root:
            return module_name, module_name
        elif ofclass.is_instanceof(root):
            if root == 'of_header':
                # The input files don't prefix message names
                return module_name, ofclass.name[3:]
            else:
                return module_name, ofclass.name[len(root)+1:]
    return 'message', ofclass.name[3:]

# Create intermediate representation, extended from the LOXI IR
def build_ofclasses(version):
    modules = defaultdict(list)
    print(map(lambda x: x.name, loxi_globals.ir[version].classes))
    for ofclass in loxi_globals.ir[version].classes:
        module_name, ofclass.pyname = generate_pyname(ofclass)
        if module_name == "message":
            print(module_name, ofclass.pyname)
            modules[module_name].append(ofclass)
    return modules

def codegen(install_dir):
    def render(name, template_name=None, **ctx):
        if template_name is None:
            template_name = os.path.basename(name)
        with template_utils.open_output(install_dir, name) as out:
            util.render_template(out, template_name, **ctx)

    version = OFVersion("1.0", 1)
    subdir = 'of' + version.version.replace('.', '')
    modules = build_ofclasses(version)

    # render(os.path.join(subdir, '__init__.py'), template_name='init.py',
    #        version=version, modules=modules.keys())
    #
    # render(os.path.join(subdir, 'util.py'), version=version)

    types = {
      'uint8_t': 'uint8',
      'uint16_t': 'uint16',
      'uint32_t': 'uint32',
      'uint64_t': 'uint64',
      'of_fm_cmd_t': 'uint16',
      'of_port_no_t':'uint16',
      'of_wc_bmap_t': 'uint32',
      'of_match_bmap_t': 'uint32',
      'of_ipv4_t': '[4]uint8',
      'of_ipv6_t': '[6]uint8',
      'of_mac_addr_t': '[6]uint8',
      'of_port_name_t': '[16]uint8',
      'of_desc_str_t': '[256]byte',
      'of_serial_num_t': '[32]byte',
      'of_table_name_t': '[32]byte',
      'of_octets_t': '[]byte',
      'ofp_capabilities': 'ofp_capabilities', #enum
      'ofp_flow_mod_flags': 'ofp_flow_mod_flags', #enum
      'ofp_flow_mod_failed_code': 'ofp_flow_mod_failed_code', #enum,
      'ofp_config_flags': 'ofp_config_flags', #enum
      'ofp_hello_failed_code': 'ofp_hello_failed_code', #enum
      'ofp_port_mod_failed_code': 'ofp_port_mod_failed_code', #enum
      'ofp_stats_reply_flags': 'ofp_stats_reply_flags', #enum
      'ofp_stats_request_flags': 'ofp_stats_request_flags', #enum
      'ofp_bad_action_code': 'ofp_bad_action_code', #enum
      'ofp_bad_request_code': 'ofp_bad_request_code', #enum
      'ofp_port_reason': 'ofp_port_reason', #enum,
      'ofp_queue_op_failed_code': 'ofp_queue_op_failed_code', #enum
      'ofp_port_config': 'ofp_port_config', #enum
      'ofp_port_state': 'ofp_port_state', #enum
      'ofp_port_features': 'ofp_port_features', #enum
      'of_match_t': 'match_v1', #we need to care specifically about parsing this
      'of_port_desc_t': 'of_port_desc' #we need to care specifically about parsing this
    }

    render(os.path.join(subdir, 'const.go'), version=version,
           enums=loxi_globals.ir[version].enums,types =types)

    for name, ofclasses in modules.items():
        render(os.path.join(subdir, name + '.go'), template_name='module.go',
               version=version, ofclasses=ofclasses, subdir=subdir,types =types)
